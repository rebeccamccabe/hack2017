
import random
from random import shuffle
import copy



class Player:
    def __init__(self, playername, is_cpu):
        self.name = playername
        self.playerhand = []
        self.chow = None
        self.is_cpu = is_cpu  # bool
        self.revealed = []  # list of tiles revealed through pung and chow moves

def draw(player):
    player.playerhand.append(walls[0])
    print("Drew: " + walls[0].name)
    del walls[0]


def turn(player, discards):
    """"takes in name of current player, player's hand as a list, and tiles as a list"""

    # set next player
    nextplayer = players_list[(players_list.index(player) + 1) % 4]
    if player.is_cpu:
        cpu_turn(player)
        user_pung = input("do you wish to pung this tile? True or False")
        if user_pung:
            punged = check_pung(user_player_1)
            pung(user_player_1)
            if punged:
                next_player = players_list[(players_list.index(user_player) + 1) % 4]
    else:
        # print current hand
        print("your current hand is:")
        playerhand_names = []
        for tile in player.playerhand:
            playerhand_names.append(tile.name)
        print(playerhand_names)

        move = input("please type draw or pung or chow to choose a move")  # user input

        # can claim most recent discard tile and pung
        if move == "pung":
            pung(player, discards)
        elif move == "chow":
            chow(player, discards)
        elif move == "draw":
            # draw a tile
            draw(player)

        #checks it whether you type in true or false :(
        mahjong = bool(input("Can you declare mahjong? type in True or False"))
        if mahjong:
            check_mahjong(player.playerhand)

        discard_tile_name = input("please choose a tile to discard")
        # user input
        # possibly could print the different tiles the player has and have them input 1 to whatever to select

        discard_tile = None
        for tile in player.playerhand:
            if tile.name == discard_tile_name:
                discard_tile = tile
        # discard a tile
        player.playerhand.remove(discard_tile)
        print("tile discarded by " + player.name + " is " + discard_tile_name)


def cpu_turn(player, discards):
    """cpus draw and random discard"""
    draw(player)
    discard_tile = random.choice(player.playerhand)
    print("tile discarded by " + player.name + " is " + discard_tile.name)
    player.playerhand.remove(discard_tile)
    discards.append(discard_tile)


# i could probably put this into pung but i won't for now
def check_pung(player, discards):
    """uses current player and discards, where the last element in discards is the tile discarded by the last player"""
    last_tile = discards[-1]
    pung_tiles = [last_tile]

    # goes through and finds matches for last_tile in the player's hand, compared using the name
    for tile in player.playerhand:
        if last_tile.name == tile.name:
            pung_tiles.append(tile)

    # checks to make sure pung is a legal move in this case
    if len(pung_tiles) != 3:
        return False
    else:
        return True


def pung(player, discards):
    """uses current player and discards, where the last element in discards is the tile discarded by the last player"""
    last_tile = discards[-1]
    pung_tiles = [last_tile]

    # goes through and finds matches for last_tile in the player's hand, compared using the name
    for tile in player.playerhand:
        if last_tile.name == tile.name:
            pung_tiles.append(tile)

    # checks to make sure pung is a legal move in this case
    if len(pung_tiles) != 3:
        print("Sorry, you do not have the correct tiles for pung")
    else:
        # take out the 2 tiles from playerhand
        player.playerhand.remove(pung_tiles[1])
        player.playerhand.remove(pung_tiles[2])

        # add list of pung tiles to revealed tiles
        player.revealed.append(pung_tiles)
        # remove tile used from discards
        discards.remove(last_tile)


def chow(player, discards):
    last_tile = discards[-1]
    suit = last_tile.suit
    chow_tiles = [last_tile]

    # using input because there could be mult possibilities for the chow, want to use the one the player intended
    chow_tile_1_name = input("please input the name of the first tile for chow")
    chow_tile_2_name = input("please input the name of the second tile for chow")

    # goes through and finds the tiles specified
    for tile in player.playerhand:
        if chow_tile_1_name == tile.name or chow_tile_2_name == tile.name:
            chow_tiles.append(tile)

    # check if tiles work (correct suit, in consecutive rank order)
    illegal = False
    tile_ranks = []
    for tile in chow_tiles:
        tile_ranks.append(tile.rank)
        if tile.suit != suit:
            illegal = True
        if tile.suit == "specials" or tile.suit == "flowers":
            illegal = True
    if tile_ranks[1] - tile_ranks[0] != 1 or tile_ranks[2] - tile_ranks[0] != 2:
        illegal = True
    if illegal:
        print("Sorry, you do not have the correct tiles for chow")

    elif len(chow_tiles) != 3:
        print("Sorry, you do not have the tiles you named")
    else:
        # take out the 2 tiles from playerhand
        player.playerhand.remove(chow_tiles[1])
        player.playerhand.remove(chow_tiles[2])

        # add list of pung tiles to revealed tiles
        player.revealed.append(chow_tiles)
        # set the player's chow variable to the suit used
        player.chow = suit
        # remove tile used from discards
        discards.remove(last_tile)


def check_mahjong(hand):
    pass


def win(player):
    raise NotImplementedError

def flower_check(player):
  for tile in player.playerhand:
    if tile.suit == "flowers":
      player.revealed.append(tile)
      player.playerhand.remove(tile)
      draw(player) #should technically draw from the back but fine for now #also if flower_check is in Player draw should be as well
      has_cash_money = True

#will need players_list global variable, walls as a global variable, and user_player as the name of one of the players
#start game play
#maybe account for skipped turns in here? by going off of "next player"?





dict_name_to_tile={"B1":["bamboo", 1], "B2":["bamboo", 2], "B3":["bamboo", 3], "B4":["bamboo", 4], "B5":["bamboo", 5],"B6":["bamboo", 6],
                   "B7": ["bamboo", 7], "B8":["bamboo", 8], "B9":["bamboo", 9],
                   "D1":["dots", 1], "D2":["dots", 2], "D3":["dots", 3], "D4":["dots", 4], "D5":["dots", 5],"D6":["dots", 6],
                   "D7": ["dots", 7], "D8":["dots", 8], "D9":["dots", 9],
                   "C1":["characters", 1], "C2":["characters", 2], "C3":["characters", 3], "C4":["characters", 4], "C5":["characters", 5],"C6":["characters", 6],
                   "C7": ["characters", 7], "C8":["characters", 8], "C9":["characters", 9],
                   "SN":["specials", 1], "SE":["specials", 2], "SS":["specials", 3], "SW":["specials", 4], "SM":["specials", 5],"SG":["specials", 6], "SB":["specials", 7],
                   "F":["flowers", 0]}

def tile_to_name(suit, rank):
  name = ""
  if suit == "bamboo":
    name += "B"
    name += str(rank+1)
  elif suit == "dots":
    name += "D"
    name += str(rank+1)
  elif suit == "characters":
    name += "C"
    name += str(rank+1)
  elif suit == "flowers":
    name = "F"
  elif suit == "specials":
    name += "S"
    specialtiles = ["N", "E", "S", "W", "M", "G", "B"]
    name += specialtiles[rank]
  return name



class Tile:
    def __init__(self, suit, rank):
        self.name=tile_to_name(suit, rank)
        self.suit=suit
        self.rank=rank
    def __repr__(self):
        return self.name

suits = ["bamboo", "dots", "characters", "specials", "flowers"]

if __name__ == "__main__":
    tileset = []
    for i in range(4): # 4 instances of each
        for j in range(len(suits) - 2): # each of the first three suits
            for k in range(9):
                t = Tile(suits[j], k)
                tileset.append(t)
        for k in range(7):
            t = Tile(suits[3], k)
            tileset.append(t)
    for i in range(8):
        tileset.append(Tile(suits[4], 0)) # adding 8 flower tiles
    print(tileset)

    walls = copy.deepcopy(tileset)
    shuffle(walls)
    discards=[]

    #set no win to true
    no_win=True
    #create players
    user_player_1= Player("player1user", False)
    cpu_player_2= Player("player2", True)
    cpu_player_3= Player("player3", True)
    cpu_player_4= Player("player4", True)

    players_list= [user_player_1, cpu_player_2, cpu_player_3, cpu_player_4]

    for player in players_list:
        for i in range(13):
            player.playerhand.append(walls[0])
            del walls[0]

    for player in players_list:
        print(player.name+": "+str(player.playerhand))
        flower_check(player)
        print(player.name+": "+str(player.playerhand))

    next_player=user_player_1

    while no_win:
        print("next player is")
        print(next_player.name)
        turn(next_player, discards) #i have no idea if this loop will work
