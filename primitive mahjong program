
import random
from random import shuffle
import copy



class Player:
    def __init__(self, playername, is_cpu):
        self.name = playername
        self.playerhand = []
        self.chow = None
        self.is_cpu = is_cpu  # bool
        self.revealed = []  # list of tiles revealed through pung and chow moves

def draw(player):
    player.playerhand.append(walls[0])
    print("Drew: " + walls[0].name)    
    del walls[0]
    flower_check(player)


def turn(player, discards):
    """"takes in name of current player, player's hand as a list, and tiles as a list"""

    # set next player
    # nextplayer = players_list[(players_list.index(player) + 1) % 4]
    # print(str(players_list.index(player) + 1))
    # print(str((players_list.index(player) + 1) % 4))
    # print("right after assignment")
    # print(nextplayer.name)
    if player.is_cpu:
        cpu_turn(player, discards)
        user_pung = input("do you wish to pung this tile? True or False: ")
        if user_pung == "True":
            punged = check_pung(user_player_1, discards)
            pung(user_player_1, discards)
            if punged:
                next_player = players_list[(players_list.index(user_player_1) + 1) % 4]
    else:
        # print current hand
        print("your current hand is: ")
        playerhand_names = []
        for tile in player.playerhand:
            playerhand_names.append(tile.name)
        print(playerhand_names)

        move = input("please type draw or pung or chow to choose a move: ")  # user input

        # can claim most recent discard tile and pung
        if move == "pung":
            pung(player, discards)
        elif move == "chow":
            chow(player, discards)
        elif move == "draw":
            # draw a tile
            draw(player)

        #checks it whether you type in true or false :(
        mahjong = bool(input("Can you declare mahjong? type in True or False: "))
        if mahjong:
            check_mahjong(player)

        discard_tile_name = input("please choose a tile to discard: ")
        # user input
        # possibly could print the different tiles the player has and have them input 1 to whatever to select

        discard_tile = None
        for tile in player.playerhand:
            if tile.name == discard_tile_name:
                discard_tile = tile
        # discard a tile
        player.playerhand.remove(discard_tile)
        discards.append(discard_tile)
        print("tile discarded by " + player.name + " is " + discard_tile_name)


def cpu_turn(player, discards):
    """cpus draw and random discard"""
    draw(player)
    discard_tile = random.choice(player.playerhand)
    print("tile discarded by " + player.name + " is " + discard_tile.name)
    player.playerhand.remove(discard_tile)
    discards.append(discard_tile)


# i could probably put this into pung but i won't for now
def check_pung(player, discards):
    """uses current player and discards, where the last element in discards is the tile discarded by the last player"""
    last_tile = discards[-1]
    pung_tiles = [last_tile]

    # goes through and finds matches for last_tile in the player's hand, compared using the name
    for tile in player.playerhand:
        if last_tile.name == tile.name:
            pung_tiles.append(tile)

    # checks to make sure pung is a legal move in this case
    if len(pung_tiles) != 3:
        return False
    else:
        return True


def pung(player, discards):
    """uses current player and discards, where the last element in discards is the tile discarded by the last player"""
    last_tile = discards[-1]
    pung_tiles = [last_tile]

    # goes through and finds matches for last_tile in the player's hand, compared using the name
    for tile in player.playerhand:
        if last_tile.name == tile.name:
            pung_tiles.append(tile)

    # checks to make sure pung is a legal move in this case
    if len(pung_tiles) != 3:
        print("Sorry, you do not have the correct tiles for pung ")
    else:
        # take out the 2 tiles from playerhand
        player.playerhand.remove(pung_tiles[1])
        player.playerhand.remove(pung_tiles[2])

        # add list of pung tiles to revealed tiles
        player.revealed.append(pung_tiles)
        # remove tile used from discards
        discards.remove(last_tile)


def chow(player, discards):
    last_tile = discards[-1]
    suit = last_tile.suit
    chow_tiles = [last_tile]

    # using input because there could be mult possibilities for the chow, want to use the one the player intended
    chow_tile_1_name = input("please input the name of the first tile for chow ")
    chow_tile_2_name = input("please input the name of the second tile for chow ")

    # goes through and finds the tiles specified
    for tile in player.playerhand:
        if chow_tile_1_name == tile.name or chow_tile_2_name == tile.name:
            chow_tiles.append(tile)

    # check if tiles work (correct suit, in consecutive rank order)
    illegal = False
    tile_ranks = []
    for tile in chow_tiles:
        tile_ranks.append(tile.rank)
        if tile.suit != suit:
            illegal = True
        if tile.suit == "specials" or tile.suit == "flowers":
            illegal = True
    if tile_ranks[1] - tile_ranks[0] != 1 or tile_ranks[2] - tile_ranks[0] != 2:
        illegal = True
    if illegal:
        print("Sorry, you do not have the correct tiles for chow ")

    elif len(chow_tiles) != 3:
        print("Sorry, you do not have the tiles you named ")
    else:
        # take out the 2 tiles from playerhand
        player.playerhand.remove(chow_tiles[1])
        player.playerhand.remove(chow_tiles[2])

        # add list of pung tiles to revealed tiles
        player.revealed.append(chow_tiles)
        # set the player's chow variable to the suit used
        player.chow = suit
        # remove tile used from discards
        discards.remove(last_tile)


def check_mahjong(player):
    hand=player.playerhand
    revealed=player.revealed
    
    numberPungsConcealed = countDupTiles('pung', hand)
    numberChowsConcealed = findChowsInHand(hand)

    exposed_counts_list = analyze_revealed(revealed)
    numberPungsExposed = exposed_counts_list[0]
    numberChowsExposed = exposed_counts_list[1]
    
    numberPungsTotal = numberPungsConcealed + numberPungsExposed
    numberChowsTotal = numberChowsConcealed + numberChowsExposed
    numberSets=numberPungsTotal + numberChowsTotal

    numberPairs = countDupTiles('pair', hand)
    
    print('Number Pungs:',numberPungsTotal,'('+ str(numberPungsConcealed) + ' in hand and',numberPungsExposed,'revealed).')
    print('Number Chows:',numberChowsTotal,'('+ str(numberChowsConcealed) + ' in hand and',numberChowsExposed,'revealed).')
    print('Number sets:',numberSets)
    print('Number pairs:',numberPairs)
    if((numberSets >= 4) & (numberPairs >= 1)):
        print('Yes, you have mahjong!')
        return True
    else:
        print('Sorry, that is not mahjong.')
        return False

def analyze_revealed(revealed):
    numberPungsExposed=0
    numberChowsExposed=0
    
    for set in revealed:
        if set[0]!=set[1]:
            numberChowsExposed+=1
        else: numberPungsExposed+=1
    numRevealed = [numberPungsExposed, numberChowsExposed]
    return numRevealed


def findChowsInHand(hand):
    numChows=0
    workingHand = copy.deepcopy(hand)
    #working hand will remove all chows that were already identified, so that (1,2,3,4) is not counted as two chows

    for i in range(0, len(workingHand)):
        if i>= len(workingHand): #because the length of working hand decreases as the loop progresses
            break
        above=-1 #the index of the tile with 1 greater rank
        below=-1 #the index of the tile with 1 less rank
        for j in range(0, len(workingHand)):
            if ((workingHand[i].suit==workingHand[j].suit) & (i!=j)):
                if workingHand[i].rank==(workingHand[j].rank)+1:
                    below=j
                elif workingHand[i].rank==(workingHand[j].rank)-1:
                    above=j
        if ((above>=0)&(below>=0)):
            numChows+=1
            workingHand.remove(workingHand[i])
            workingHand.remove(workingHand[above])    
            workingHand.remove(workingHand[below])
    return numChows      

    
def countDupTiles(pungOrPair, hand):
    if pungOrPair == 'pung': #for pung, you must have at least 3 tiles
        lower=3
        upper=10
    else: #for pair, you must have exactly 2 tiles
        lower=2
        upper=2
        
    numSets=0
    
    indicesWithDups=[]
    #the indices of hand which contain duplicate numbers, so the dups aren't counted twice
    
    for i in range(0, len(hand)-1):       
        indicesWithThisNumber=[] #the indices of hand which contain duplicates of the particular tile at i
        if indicesWithDups.count(i)==0:
            for j in range(i+1, len(hand)): #check each tile with other tiles ahead of it           
                if (indicesWithThisNumber.count(j)==0):
                    if ((hand[i].rank == hand[j].rank) & (hand[i].suit == hand[j].suit)): #if the tiles are equal
                        if len(indicesWithThisNumber)==0: #only add i to the list on the first time around 
                            indicesWithThisNumber.append(i)
                            indicesWithDups.append(i)
                        indicesWithThisNumber.append(j)
                        indicesWithDups.append(j)
        numOccurrences=len(indicesWithThisNumber)
        if((numOccurrences>=lower) & (numOccurrences<=upper)):
            numSets+=1
    return numSets

def win(player):
    raise NotImplementedError

def flower_check(player):
  for tile in player.playerhand:
    if tile.suit == "flowers":
      player.revealed.append(tile)
      player.playerhand.remove(tile)
      print("Flower!")
      draw(player) #should technically draw from the back but fine for now #also if flower_check is in Player draw should be as well
      has_cash_money = True

#will need players_list global variable, walls as a global variable, and user_player as the name of one of the players
#start game play
#maybe account for skipped turns in here? by going off of "next player"?



dict_name_to_tile={"B1":["bamboo", 1], "B2":["bamboo", 2], "B3":["bamboo", 3], "B4":["bamboo", 4], "B5":["bamboo", 5],"B6":["bamboo", 6],
                   "B7": ["bamboo", 7], "B8":["bamboo", 8], "B9":["bamboo", 9],
                   "D1":["dots", 1], "D2":["dots", 2], "D3":["dots", 3], "D4":["dots", 4], "D5":["dots", 5],"D6":["dots", 6],
                   "D7": ["dots", 7], "D8":["dots", 8], "D9":["dots", 9],
                   "C1":["characters", 1], "C2":["characters", 2], "C3":["characters", 3], "C4":["characters", 4], "C5":["characters", 5],"C6":["characters", 6],
                   "C7": ["characters", 7], "C8":["characters", 8], "C9":["characters", 9],
                   "SN":["specials", 1], "SE":["specials", 2], "SS":["specials", 3], "SW":["specials", 4], "SM":["specials", 5],"SG":["specials", 6], "SB":["specials", 7],
                   "F":["flowers", 0]}

def tile_to_name(suit, rank):
  name = ""
  if suit == "bamboo":
    name += "B"
    name += str(rank+1)
  elif suit == "dots":
    name += "D"
    name += str(rank+1)
  elif suit == "characters":
    name += "C"
    name += str(rank+1)
  elif suit == "flowers":
    name = "F"
  elif suit == "specials":
    name += "S"
    specialtiles = ["N", "E", "S", "W", "M", "G", "B"]
    name += specialtiles[rank]
  return name



class Tile:
    def __init__(self, suit, rank):
        self.name=tile_to_name(suit, rank)
        self.suit=suit
        self.rank=rank
    def __repr__(self):
        return self.name

suits = ["bamboo", "dots", "characters", "specials", "flowers"]

if __name__ == "__main__":
    tileset = []
    for i in range(4): # 4 instances of each
        for j in range(len(suits) - 2): # each of the first three suits
            for k in range(9):
                t = Tile(suits[j], k)
                tileset.append(t)
        for k in range(7):
            t = Tile(suits[3], k)
            tileset.append(t)
    for i in range(8):
        tileset.append(Tile(suits[4], 0)) # adding 8 flower tiles
    print(tileset)

    walls = copy.deepcopy(tileset)
    shuffle(walls)
    discards=[]

    #set no win to true
    no_win=True
    #create players
    user_player_1= Player("player1user", False)
    cpu_player_2= Player("player2", True)
    cpu_player_3= Player("player3", True)
    cpu_player_4= Player("player4", True)

    players_list= [user_player_1, cpu_player_2, cpu_player_3, cpu_player_4]

    for player in players_list:
        for i in range(13):
            player.playerhand.append(walls[0])
            del walls[0]

    for player in players_list:
        print(player.name+": "+str(player.playerhand))
        flower_check(player)
        print(player.name+": "+str(player.playerhand))

    next_player=user_player_1


    while no_win:
        turn(next_player, discards) #i have no idea if this loop will work
        # set next player
        next_player = players_list[(players_list.index(next_player) + 1) % 4]
